#include <vector>
#include <iostream>
#include <limits>
#include <time.h>       /* time */
// http://community.topcoder.com/tc?module=Static&d1=tutorials&d2=hungarianAlgorithm

using namespace std;

// --------------------------------------------------------------------------
//
// --------------------------------------------------------------------------
template<typename costType>
class CHungarian
{
private:	
	costType** cost;     //Матрица стоимостей
	int n;				 //n рабочих и n работ
	int *xy;             //xy[x] - vertex that is matched with x
	int max_match;		 
	costType *lx, *ly;   //labels of X and Y parts
	int *yx;             //yx[y] - vertex that is matched with y
	int *S;
	int *T;				 //sets S and T in algorithm
	costType *slack;     //as in the algorithm description
	int *slackx;         //slackx[y] such a vertex, that
	// l(slackx[y]) + l(y) - w(slackx[y],y) = slack[y]
	int *prev;           //array for memorizing alternating paths

	void init_labels();
	void update_labels();
	void add_to_tree(int x, int prevx);
	void augment();

public:

	CHungarian(vector<vector<costType>>& Cost);
	~CHungarian();
	costType  Run(vector<int>& _xy);
	int  getN(void);
};


// --------------------------------------------------------------------------
//
// --------------------------------------------------------------------------
template<typename costType>
int CHungarian<costType>::getN(void)
{
return n;
}
// --------------------------------------------------------------------------
//
// --------------------------------------------------------------------------
template<typename costType>
CHungarian<costType>::~CHungarian()
{
	for(int i=0; i<n; i++)
	{
		delete[] cost[i];
	}
	delete[] cost;
	delete[] lx;
	delete[] ly;
	delete[] xy;
	delete[] yx;
	delete[] S;
	delete[] T;
	delete[] slack;
	delete[] slackx;
	delete[] prev;
}
// --------------------------------------------------------------------------
//
// --------------------------------------------------------------------------
template<typename costType>
CHungarian<costType>::CHungarian(vector<vector<costType>>& Cost)
{
	n=Cost.size();				// n workers

	cost=new costType*[n];      // cost matrix
	for(int i=0; i<n; i++)
	{
		cost[i]=new costType[n];
	}

	for(int i=0; i<n; i++)
	{
		for(int j=0; j<n; j++)
		{
			cost[i][j]=Cost[i][j];
		}	
	}

	max_match=0;				// n jobs
	lx=new costType[n];			// labels of X parts
	ly=new costType[n];			// labels of Y parts
	xy=new int[n];              // xy[x] - vertex that is matched with x,
	yx=new int[n];              // yx[y] - vertex that is matched with y
	S=new int[n];
	T=new int[n];               // sets S and T in algorithm
	slack=new costType[n];      // as in the algorithm description
	slackx=new int[n];          // slackx[y] such a vertex, that
	prev=new int[n];            //array for memorizing alternating paths
}
// --------------------------------------------------------------------------
//
// --------------------------------------------------------------------------
template<typename costType>
void CHungarian<costType>::init_labels()
{
	for (int x = 0; x < n; x++)
	{
		lx[x]=0;
		ly[x]=0;
		for (int y = 0; y < n; y++)
		{
			lx[x] = std::max(lx[x], cost[x][y]);
		}
	}
}
// --------------------------------------------------------------------------
//
// --------------------------------------------------------------------------
template<typename costType>
void CHungarian<costType>::update_labels()
{
	int x, y;
	costType delta = std::numeric_limits<costType>::max(); //init delta as infinity
	for (y = 0; y < n; y++)								   //calculate delta using slack
	{
		if (!T[y])
		{
			delta = std::min(delta, slack[y]);
			slack[y] -= delta;
		}
		else
		{
			ly[y] += delta;
		}
	}
	for (x = 0; x < n; x++)            //update X labels
	{
		if (S[x])
		{
			lx[x] -= delta;
		}
	}
}
// --------------------------------------------------------------------------
//
// --------------------------------------------------------------------------
template<typename costType>
void CHungarian<costType>::add_to_tree(int x, int prevx)
	//x - current vertex,prevx - vertex from X before x in the alternating path,
	//so we add edges (prevx, xy[x]), (xy[x], x)
{
	S[x] = true;                    //add x to S
	prev[x] = prevx;                //we need this when augmenting
	costType tmp;
	for (int y = 0; y < n; y++)    //update slacks, because we add new vertex to S
	{
		tmp=lx[x] + ly[y] - cost[x][y];
		if (tmp < slack[y])
		{
			slack[y] = tmp;
			slackx[y] = x;
		}
	}
}
// --------------------------------------------------------------------------
//
// --------------------------------------------------------------------------
template<typename costType>
void CHungarian<costType>::augment() //main function of the algorithm
{
	if (max_match == n)
	{
		return;						//check wether matching is already perfect
	}
	int x, y, root;                 //just counters and root vertex
	int *q=new int[n];				// q - queue for bfs
	int wr = 0;
	int rd = 0;						// wr,rd - write and read
	//pos in queue
	for (x = 0; x < n; x++)         //finding root of the tree
	{
		S[x]=0;
		T[x]=0;
		prev[x]=-1;
		if (xy[x] == -1)
		{
			q[wr++] = root = x;
			prev[x] = -2;
			S[x] = true;
			break;
		}
	}
	for (y = 0; y < n; y++)            //initializing slack array
	{
		slack[y] = lx[root] + ly[y] - cost[root][y];
		slackx[y] = root;
	}
	//second part of augment() function
	while (true)                      //main cycle
	{
		while (rd < wr)               //building tree with bfs cycle
		{
			x = q[rd++];              //current vertex from X part
			for (y = 0; y < n; y++)   //iterate through all edges in equality graph
			{
				if (cost[x][y] == (lx[x] + ly[y]) &&  !T[y])
				{
					if (yx[y] == -1)
					{
						break;    //an exposed vertex in Y found, so
					}
					//augmenting path exists!
					T[y] = true;            //else just add y to T,
					q[wr++] = yx[y];        //add vertex yx[y], which is matched
					//with y, to the queue
					add_to_tree(yx[y], x);  //add edges (x,y) and (y,yx[y]) to the tree
				}
			}
			if (y < n)
			{
				break;    //augmenting path found!
			}
		}
		if (y < n)
		{
			break;    //augmenting path found!
		}
		update_labels();  //augmenting path not found, so improve labeling
		wr = rd = 0;
		for (y = 0; y < n; y++)
		{
			//in this cycle we add edges that were added to the equality graph as a
			//result of improving the labeling, we add edge (slackx[y], y) to the tree if
			//and only if !T[y] &&  slack[y] == 0, also with this edge we add another one
			//(y, yx[y]) or augment the matching, if y was exposed
			if (!T[y] &&  slack[y] == 0)
			{
				if (yx[y] == -1)                         //exposed vertex in Y found - augmenting path exists!
				{
					x = slackx[y];
					break;
				}
				else
				{
					T[y] = true;                         //else just add y to T,
					if (!S[yx[y]])
					{
						q[wr++] = yx[y];                 //add vertex yx[y], which is matched with
						//y, to the queue
						add_to_tree(yx[y], slackx[y]);   //and add edges (x,y) and (y,
						//yx[y]) to the tree
					}
				}
			}
		}
		if (y < n)
		{
			break;    //augmenting path found!
		}
	}
	if (y < n)                                                          //we found augmenting path!
	{
		max_match++;                                                    //increment matching
		//in this cycle we inverse edges along augmenting path
		for (int cx = x, cy = y, ty; cx != -2; cx = prev[cx], cy = ty)
		{
			ty = xy[cx];
			yx[cy] = cx;
			xy[cx] = cy;
		}
		augment();  //recall function, go to step 1 of the algorithm
	}
	delete[] q;
}//end of augment() function
// --------------------------------------------------------------------------
//
// --------------------------------------------------------------------------
template<typename costType>
costType CHungarian<costType>::Run(vector<int>& _xy)
{
	costType ret = 0;           //weight of the optimal matching
	max_match = 0;              //number of vertices in current matching
	for(int i=0; i<n; i++)
	{
		xy[i]=-1;
		yx[i]=-1;
		for(int j=0; j<n; j++)
		{
			cost[i][j]*=-1.0;
		}
	}
	init_labels();              //step 0
	augment();                  //steps 1-3
	for(int i=0; i<n; i++)
	{
		for(int j=0; j<n; j++)
		{
			cost[i][j]*=-1.0;
		}
	}

	// Назначения
	_xy.clear();
	// Результирующая стоимость
	for (int x = 0; x < n; x++) //forming answer there
	{
		ret += cost[x][xy[x]];
		_xy.push_back(xy[x]);

	}


	return ret;
}
// --------------------------------------------------------------------------
//
// --------------------------------------------------------------------------
/*
	void main(void)
{
	// Размер матрицы
	int N=8;

	// Инициализация генератора случайных чисел
	srand (time(NULL));

	// Матрица стоимостей
	vector< vector<float> > Cost(N,vector<float>(N));

	// Заполняем матрицу случайными числами
	for(int i=0; i<N; i++)
	{
		for(int j=0; j<N; j++)
		{
			Cost[i][j]= (float)(rand()%1000)/1000.0;
			std::cout << Cost[i][j] << "\t";
		}
		std::cout << std::endl;
	}

	// Собственно сам процесс
	CHungarian<float>* H=new CHungarian<float>(Cost);
	vector<int> xy;
	std::cout << H->Run(xy) << std::endl;
	
	// Вывод результата
	for(int x=0; x<xy.size(); x++)
	{
		std::cout << x << ":" << xy[x] << "\t";
	}

	std::cout << std::endl;
	getchar();
	delete H;
}
*/
// --------------------------------------------------------------------------